"use strict";(self.webpackChunkdocs_crashr_io=self.webpackChunkdocs_crashr_io||[]).push([[6486],{3183:(t,n,e)=>{e.r(n),e.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>a,toc:()=>d});var i=e(4848),s=e(8453);const o={description:"Point System of Crashr"},r="Points Incentive",a={id:"points",title:"Points Incentive",description:"Point System of Crashr",source:"@site/docs/points.md",sourceDirName:".",slug:"/points",permalink:"/docs/points",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/points.md",tags:[],version:"current",frontMatter:{description:"Point System of Crashr"},sidebar:"tutorialSidebar",previous:{title:"$CRASH Staking",permalink:"/docs/tokenomics/usdcrash-staking"}},c={},d=[{value:"<strong>Acquisition of Points</strong>",id:"acquisition-of-points",level:2},{value:"Points System Dynamics",id:"points-system-dynamics",level:2},{value:"Current Points v1.0",id:"current-points-v10",level:2},{value:"Conclusion",id:"conclusion",level:2}];function l(t){const n={h1:"h1",h2:"h2",img:"img",li:"li",p:"p",strong:"strong",ul:"ul",...(0,s.R)(),...t.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"points-incentive",children:"Points Incentive"}),"\n",(0,i.jsx)(n.h2,{id:"acquisition-of-points",children:(0,i.jsx)(n.strong,{children:"Acquisition of Points"})}),"\n",(0,i.jsx)(n.p,{children:"Points are awarded to both the buyer and seller of a transaction, equivalent in value to the ADA involved. For example: If your transaction is worth 100 ADA, you and the other party receive 100 Points that are linked to the connected wallet."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"Points",src:e(4022).A+"",width:"1200",height:"675"})}),"\n",(0,i.jsx)(n.h2,{id:"points-system-dynamics",children:"Points System Dynamics"}),"\n",(0,i.jsx)(n.p,{children:"Instead of directly awarding $CRASH tokens for every transaction, Crashr introduces a points system. This approach is developed to prevent the rapid dispersion of tokens and to allow all protocol users to be fairly rewarded. Each quarter, the points will be converted into $CRASH tokens, dependent on the distribution and vesting of the token. "}),"\n",(0,i.jsx)(n.p,{children:"Ecosystem benefits:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Mitigating Volatility:"})," By awarding points for transactions instead of tokens, we minimize the risk of token over saturation. This careful control helps maintain the token's value and ensures a stable trading environment."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Flexible Rewards:"})," Users accumulate points through their activity on Crashr which than users can convert to $CRASH tokens."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"current-points-v10",children:"Current Points v1.0"}),"\n",(0,i.jsx)(n.p,{children:"Points are currently awarded to users for staking our NFT collection and to early testers of Crashr v1.0. Upon the Token Generation Event (TGE), these users will receive an airdrop of $CRASH Tokens, determined by the number of points they have at that time. With the introduction of the new points dynamic, staking will be phased out, making trading the sole way to earn points on our platform. Until this new system is in place, users can gain points by both staking and trading on v1.0."}),"\n",(0,i.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,i.jsx)(n.p,{children:"Our points system is to creating a sustainable, user-centric trading platform. By innovating beyond traditional token rewards, we offer a balanced approach that rewards users while maintaining the integrity and value of the ecosystem. "})]})}function h(t={}){const{wrapper:n}={...(0,s.R)(),...t.components};return n?(0,i.jsx)(n,{...t,children:(0,i.jsx)(l,{...t})}):l(t)}},4022:(t,n,e)=>{e.d(n,{A:()=>i});const i=e.p+"assets/images/points-2c4dc05d1f048e52f733bd5a2c485f96.png"},8453:(t,n,e)=>{e.d(n,{R:()=>r,x:()=>a});var i=e(6540);const s={},o=i.createContext(s);function r(t){const n=i.useContext(o);return i.useMemo((function(){return"function"==typeof t?t(n):{...n,...t}}),[n,t])}function a(t){let n;return n=t.disableParentContext?"function"==typeof t.components?t.components(s):t.components||s:r(t.components),i.createElement(o.Provider,{value:n},t.children)}}}]);